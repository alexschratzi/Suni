# Supabase schema notes

These screens expect the following tables and columns. If your schema uses
different names, update `src/lib/supabaseTables.ts` to match.

profiles
- id (uuid, PK, auth user id)
- username (text)
- role (text)
- settings (jsonb)
- avatar_path (text, storage path)

SQL helpers
```
alter table profiles
  add column if not exists avatar_path text;
```

DM threads: enforce unique pair + helper RPCs
```
-- Ensure one thread per user pair.
alter table dm_threads
  add column if not exists user_a uuid,
  add column if not exists user_b uuid;

update dm_threads
set user_a = least(users[1], users[2]),
    user_b = greatest(users[1], users[2])
where (user_a is null or user_b is null)
  and array_length(users, 1) >= 2;

alter table dm_threads
  alter column user_a set not null,
  alter column user_b set not null;

alter table dm_threads
  add constraint dm_threads_user_pair_unique unique (user_a, user_b);

alter table dm_threads
  add constraint dm_threads_user_pair_check check (user_a < user_b);

create or replace function public.dm_threads_set_pair()
returns trigger
language plpgsql
as $$
begin
  if new.users is not null and array_length(new.users, 1) >= 2 then
    new.user_a := least(new.users[1], new.users[2]);
    new.user_b := greatest(new.users[1], new.users[2]);
  end if;
  return new;
end;
$$;

drop trigger if exists dm_threads_set_pair_before on dm_threads;
create trigger dm_threads_set_pair_before
before insert or update of users on dm_threads
for each row execute procedure public.dm_threads_set_pair();

-- RPC: get or create the unique thread for a pair (also unhide for caller).
create or replace function public.get_or_create_dm_thread(user_a uuid, user_b uuid)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  a uuid;
  b uuid;
  thread_id uuid;
begin
  if user_a is null or user_b is null or user_a = user_b then
    raise exception 'invalid users';
  end if;

  a := least(user_a, user_b);
  b := greatest(user_a, user_b);

  insert into dm_threads (users, user_a, user_b, last_message, last_timestamp, hidden_by)
  values (array[a, b], a, b, '', null, '{}')
  on conflict (user_a, user_b)
  do update set hidden_by = array_remove(dm_threads.hidden_by, auth.uid())
  returning id into thread_id;

  return thread_id;
end;
$$;

grant execute on function public.get_or_create_dm_thread(uuid, uuid) to authenticated;

-- RPC: unread counts per thread for the current user.
create or replace function public.get_unread_dm_counts(p_user_id uuid default auth.uid())
returns table (thread_id uuid, unread_count bigint)
language sql
security definer
set search_path = public
as $$
  select
    m.thread_id,
    count(*)::bigint as unread_count
  from dm_messages m
  join dm_threads t on t.id = m.thread_id
  left join dm_reads r
    on r.thread_id = m.thread_id
   and r.user_id = p_user_id
  where p_user_id = any(t.users)
    and m.sender <> p_user_id
    and (r.last_read_at is null or m.timestamp > r.last_read_at)
  group by m.thread_id;
$$;

grant execute on function public.get_unread_dm_counts(uuid) to authenticated;
```

Room threads: groups + visibility + search
```
create table if not exists room_threads (
  thread_key text primary key,
  thread_number bigint generated by default as identity unique,
  title text not null,
  subtitle text,
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists room_groups (
  group_key text primary key,
  name text not null,
  description text,
  created_at timestamptz not null default now()
);

create table if not exists room_thread_groups (
  thread_key text not null references room_threads(thread_key) on delete cascade,
  group_key text not null references room_groups(group_key) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (thread_key, group_key)
);

create table if not exists room_group_memberships (
  user_id uuid not null references profiles(id) on delete cascade,
  group_key text not null references room_groups(group_key) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (user_id, group_key)
);

create table if not exists room_thread_subscriptions (
  user_id uuid not null references profiles(id) on delete cascade,
  thread_key text not null references room_threads(thread_key) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (user_id, thread_key)
);

create index if not exists room_thread_groups_group_key_idx
  on room_thread_groups (group_key);
create index if not exists room_group_memberships_user_idx
  on room_group_memberships (user_id);
create index if not exists room_thread_subscriptions_user_idx
  on room_thread_subscriptions (user_id);

-- Example seed (run via service role / scraper):
-- insert into room_groups (group_key, name) values
--   ('salzburg', 'Salzburg'),
--   ('fh-salzburg', 'FH Salzburg');
-- insert into room_threads (thread_key, thread_number, title, subtitle) values
--   ('salzburg', 1, 'Salzburg', 'Allgemeiner Thread fuer Salzburg');
-- insert into room_thread_groups (thread_key, group_key) values
--   ('salzburg', 'salzburg'),
--   ('salzburg', 'fh-salzburg');

create or replace function public.get_visible_room_threads(p_user_id uuid default auth.uid())
returns table (thread_key text, thread_number bigint, title text, subtitle text)
language sql
security definer
set search_path = public
as $$
  select
    t.thread_key,
    t.thread_number,
    t.title,
    t.subtitle
  from room_threads t
  where p_user_id = auth.uid()
    and t.is_active = true
    and (
      exists (
        select 1
        from room_thread_subscriptions s
        where s.thread_key = t.thread_key and s.user_id = p_user_id
      )
      or exists (
        select 1
        from room_thread_groups tg
        join room_group_memberships gm
          on gm.group_key = tg.group_key
         and gm.user_id = p_user_id
        where tg.thread_key = t.thread_key
      )
    )
  order by t.title;
$$;

grant execute on function public.get_visible_room_threads(uuid) to authenticated;

create or replace function public.search_room_threads(
  p_query text,
  p_user_id uuid default auth.uid(),
  p_limit int default 50,
  p_offset int default 0
)
returns table (thread_key text, thread_number bigint, title text, subtitle text, is_visible boolean)
language sql
security definer
set search_path = public
as $$
  with base as (
    select
      t.thread_key,
      t.thread_number,
      t.title,
      t.subtitle,
      (
        exists (
          select 1
          from room_thread_subscriptions s
          where s.thread_key = t.thread_key and s.user_id = p_user_id
        )
        or exists (
          select 1
          from room_thread_groups tg
          join room_group_memberships gm
            on gm.group_key = tg.group_key
           and gm.user_id = p_user_id
          where tg.thread_key = t.thread_key
        )
      ) as is_visible
    from room_threads t
    where p_user_id = auth.uid()
      and t.is_active = true
      and (
        p_query is null
        or p_query = ''
        or t.title ilike '%' || p_query || '%'
        or t.thread_key ilike '%' || p_query || '%'
      )
  )
  select *
  from base
  order by is_visible desc, title
  limit p_limit offset p_offset;
$$;

grant execute on function public.search_room_threads(text, uuid, int, int) to authenticated;

create or replace function public.subscribe_room_thread(p_thread_key text)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if p_thread_key is null or p_thread_key = '' then
    raise exception 'invalid thread key';
  end if;

  insert into room_thread_subscriptions (user_id, thread_key)
  values (auth.uid(), p_thread_key)
  on conflict do nothing;
end;
$$;

grant execute on function public.subscribe_room_thread(text) to authenticated;

-- RLS examples (adjust as needed):
-- alter table room_threads enable row level security;
-- create policy "room_threads read" on room_threads
--   for select to authenticated using (true);
-- alter table room_groups enable row level security;
-- create policy "room_groups read" on room_groups
--   for select to authenticated using (true);
-- alter table room_thread_groups enable row level security;
-- create policy "room_thread_groups read" on room_thread_groups
--   for select to authenticated using (true);
-- alter table room_group_memberships enable row level security;
-- create policy "room_group_memberships read" on room_group_memberships
--   for select to authenticated using (user_id = auth.uid());
-- alter table room_thread_subscriptions enable row level security;
-- create policy "room_thread_subscriptions read" on room_thread_subscriptions
--   for select to authenticated using (user_id = auth.uid());
-- create policy "room_thread_subscriptions insert" on room_thread_subscriptions
--   for insert to authenticated with check (user_id = auth.uid());
-- create policy "room_thread_subscriptions delete" on room_thread_subscriptions
--   for delete to authenticated using (user_id = auth.uid());
```

usernames
- username (text)
- uid (uuid)

friend_requests
- from_id (uuid, FK -> profiles.id)
- to_id (uuid, FK -> profiles.id)
- created_at (timestamptz)

friendships
- user_a (uuid, FK -> profiles.id)
- user_b (uuid, FK -> profiles.id)
- created_at (timestamptz)

blocks
- blocker_id (uuid, FK -> profiles.id)
- blocked_id (uuid, FK -> profiles.id)
- created_at (timestamptz)

dm_threads
- id (uuid, PK)
- users (uuid[] , array of two user ids)
- user_a (uuid, lower user id for uniqueness)
- user_b (uuid, higher user id for uniqueness)
- last_message (text)
- last_timestamp (timestamptz)
- hidden_by (uuid[] optional)

dm_messages
- id (uuid, PK)
- thread_id (uuid, FK -> dm_threads.id)
- sender (uuid, FK -> profiles.id)
- username (text)
- text (text)
- timestamp (timestamptz)
- attachment_path (text)
- attachment_name (text)
- attachment_mime (text)
- attachment_size (bigint)

dm_reads
- thread_id (uuid, FK -> dm_threads.id)
- user_id (uuid, FK -> profiles.id)
- last_read_at (timestamptz)
- PK: (thread_id, user_id)

room_threads
- thread_key (text, PK, unique LV key from scraper; slug-safe)
- thread_number (bigint, unique numeric id)
- title (text, display name)
- subtitle (text)
- is_active (boolean)
- created_at (timestamptz)
- updated_at (timestamptz)

room_groups
- group_key (text, PK)
- name (text)
- description (text)
- created_at (timestamptz)

room_thread_groups
- thread_key (text, FK -> room_threads.thread_key)
- group_key (text, FK -> room_groups.group_key)
- created_at (timestamptz)
- PK: (thread_key, group_key)

room_group_memberships
- user_id (uuid, FK -> profiles.id)
- group_key (text, FK -> room_groups.group_key)
- created_at (timestamptz)
- PK: (user_id, group_key)

room_thread_subscriptions
- user_id (uuid, FK -> profiles.id)
- thread_key (text, FK -> room_threads.thread_key)
- created_at (timestamptz)
- PK: (user_id, thread_key)

room_messages
- id (uuid, PK)
- room (text, thread_key)
- sender (uuid, FK -> profiles.id)
- username (text)
- text (text)
- timestamp (timestamptz)
- attachment_path (text)
- attachment_name (text)
- attachment_mime (text)
- attachment_size (bigint)

room_replies
- id (uuid, PK)
- message_id (uuid, FK -> room_messages.id)
- sender (uuid, FK -> profiles.id)
- username (text)
- text (text)
- timestamp (timestamptz)
- attachment_path (text)
- attachment_name (text)
- attachment_mime (text)
- attachment_size (bigint)

room_reply_votes
- reply_id (uuid, FK -> room_replies.id)
- user_id (uuid, FK -> profiles.id)
- value (smallint, +1/-1)
- PK: (reply_id, user_id)

room_message_votes
- message_id (uuid, FK -> room_messages.id)
- user_id (uuid, FK -> profiles.id)
- value (smallint, +1/-1)
- PK: (message_id, user_id)

RLS
- Allow authenticated users to read `profiles.username` and `profiles.avatar_path`.
- Allow users to update their own `profiles` row (username/avatar_path).
- Allow users to read/write their own friend requests, friendships, blocks,
  DM threads/messages, and room messages/replies as needed.
- Allow users to read/write their own dm_reads rows (thread_id + user_id).
- Allow authenticated users to read room_threads/room_groups and thread-group mappings.
- Allow users to read their own room_group_memberships rows (user_id).
- Allow users to insert/delete their own room_thread_subscriptions rows (user_id).
- Allow authenticated users to read room_reply_votes; allow users to insert/update/delete their own vote.
- Allow authenticated users to read room_message_votes; allow users to insert/update/delete their own vote.
Storage
- Bucket: chat_attachments (private; use signed URLs).
- Bucket: avatars (private; use signed URLs; store as `${auth.uid()}/filename`).

Avatars storage policy (example)
```
-- Allow authenticated users to read all avatars
create policy "avatars read"
on storage.objects for select
to authenticated
using (bucket_id = 'avatars');

-- Allow users to manage files only in their own folder
create policy "avatars insert"
on storage.objects for insert
to authenticated
with check (
  bucket_id = 'avatars'
  and (storage.foldername(name))[1] = auth.uid()::text
);

create policy "avatars update"
on storage.objects for update
to authenticated
using (
  bucket_id = 'avatars'
  and (storage.foldername(name))[1] = auth.uid()::text
)
with check (
  bucket_id = 'avatars'
  and (storage.foldername(name))[1] = auth.uid()::text
);

create policy "avatars delete"
on storage.objects for delete
to authenticated
using (
  bucket_id = 'avatars'
  and (storage.foldername(name))[1] = auth.uid()::text
);
```
